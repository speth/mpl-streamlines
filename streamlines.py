""" Streamline calculations """
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl


class Streamlines(object):
    def __init__(self, X, Y, U, V, res=0.1, spacing=4, maxLen=50, detectLoops=True):
        """
        Compute a set of streamlines covering the given velocity field.

        X and Y are 2D arrays of the grid points (e.g. generated by np.meshgrid)
        U and V are 2D arrays of the velocity field
        res sets the distance between successive points in each streamline (same units as X and Y)
        spacing sets the minimum density of streamlines, in grid points
        maxLen is the maximum length of an individual streamline segment
        detectLoops determines whether an attempt is made to stop extending a given streamline
            before reaching maxLen points if it forms a closed loop
        """

        self.field = VelocityField(X, Y, U, V)
        self.spacing = spacing
        self.detectLoops = detectLoops
        self.maxLen = maxLen
        self.res = res

        self.dr = self.res * np.sqrt(self.field.dx * self.field.dy)

        self.data = []
        while not self.field.used.all():
            nz = np.transpose(np.logical_not(self.field.used).nonzero())
            # Make a streamline starting at the first unrepresented grid point
            self.data.append(self.makeStreamline(self.field.x[nz[0][1]],
                                                 self.field.y[nz[0][0]]))

    def plotStreamlines(self, **kwargs):
        lw = kwargs.get('lw', 1)

        ax = kwargs.get('ax') or plt.axes()

        for streamline in self.data:
            plt.plot(streamline[0], streamline[1], 'k', lw=lw)

        ax.axis('tight')

        return ax

    def plotStreamlinesArrows(self, **kwargs):
        mutation_scale = kwargs.get('mutation_scale', 16) # size of the arrow head
        lw = kwargs.get('lw', 1)

        ax = kwargs.get('ax') or plt.axes()

        for streamline in self.data:
            path = mpl.path.Path(np.asarray((streamline[0], streamline[1])).T)
            patch = mpl.patches.FancyArrowPatch(path=path, arrowstyle='->',
                                                mutation_scale=mutation_scale, lw=lw)
            ax.add_patch(patch)

        ax.axis('tight')

        return ax

    def makeStreamline(self, x0, y0):
        xmin = self.field.x[0]
        xmax = self.field.x[-1]
        ymin = self.field.y[0]
        ymax = self.field.y[-1]

        # forwards:
        sx = [x0]
        sy = [y0]

        x = x0
        y = y0
        i = 0
        while xmin < x < xmax and ymin < y < ymax:
            u, v = self.field.interp(x, y, self.spacing)
            theta = np.arctan2(v,u)

            x += self.dr * np.cos(theta)
            y += self.dr * np.sin(theta)
            sx.append(x)
            sy.append(y)

            i += 1

            if self.detectLoops and i % 10 == 0 and self.detectLoop(sx, sy):
                break

            if i > self.maxLen / 2:
                break

        # backwards
        rx = []
        ry = []

        x = x0
        y = y0
        i = 0
        while xmin < x < xmax and ymin < y < ymax:
            u, v = self.field.interp(x, y, self.spacing)
            theta = np.arctan2(v,u)

            x -= self.dr * np.cos(theta)
            y -= self.dr * np.sin(theta)
            rx.append(x)
            ry.append(y)

            i += 1

            if self.detectLoops and  i % 10 == 0 and self.detectLoop(rx, ry):
                break

            if i > self.maxLen/2:
                break

        rx.reverse()
        ry.reverse()

        return rx+sx, ry+sy

    def detectLoop(self, xVals, yVals):
        # Detect closed loops and nodes
        x = xVals[-1]
        y = yVals[-1]
        D = np.array([np.hypot(x-xj, y-yj)
                      for xj,yj in zip(xVals[:-1],yVals[:-1])])
        return (D < 0.9 * self.dr).any()


class VelocityField:
    def __init__(self, x, y, u, v):
        xa = np.asarray(x)
        ya = np.asarray(y)
        self.x = xa if xa.ndim == 1 else xa[0]
        self.y = ya if ya.ndim == 1 else ya[:,0]
        self.u = u
        self.v = v
        self.dx = (self.x[-1]-self.x[0])/(self.x.size-1) # assume a regular grid
        self.dy = (self.y[-1]-self.y[0])/(self.y.size-1) # assume a regular grid

        # marker for which regions have contours
        self.used = np.zeros(u.shape, dtype=bool)
        self.used[0] = True
        self.used[-1] = True
        self.used[:,0] = True
        self.used[:,-1] = True

        self.markEmpty()

    def markEmpty(self):
        for i in range(self.x.size):
            for j in range(self.y.size):
                if self.u[j,i] == 0.0 and self.v[j,i] == 0.0:
                    self.used[j,i] = True


    def interp(self, x, y, spacing):
        i = (x-self.x[0])/self.dx
        ai = i % 1

        j = (y-self.y[0])/self.dy
        aj = j % 1

        # Bilinear interpolation
        u = (self.u[j,i]*(1-ai)*(1-aj) +
             self.u[j,i+1]*ai*(1-aj) +
             self.u[j+1,i]*(1-ai)*aj +
             self.u[j+1,i+1]*ai*aj)

        v = (self.v[j,i]*(1-ai)*(1-aj) +
             self.v[j,i+1]*ai*(1-aj) +
             self.v[j+1,i]*(1-ai)*aj +
             self.v[j+1,i+1]*ai*aj)

        self.used[j:j+spacing,i:i+spacing] = True

        return u,v


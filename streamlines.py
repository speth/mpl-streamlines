""" Streamline calculations """
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl


def computeStreamlines(X, Y, U, V, res=0.1, spacing=4, maxLen=50, detectLoops=True):
    """
    Compute a set of streamlines covering the given velocity field.

    X and Y are 2D arrays of the grid points (e.g. generated by np.meshgrid)
    U and V are 2D arrays of the velocity field
    res sets the distance between successive points in each streamline (same units as X and Y)
    spacing sets the minimum density of streamlines, in grid points
    maxLen is the maximum length of an individual streamline segment
    detectLoops determines whether an attempt is made to stop extending a given streamline
        before reaching maxLen points if it forms a closed loop
    """
    F = VelocityField(X, Y, U, V)

    streamlines = []
    while not F.used.all():
        nz = np.transpose(np.logical_not(F.used).nonzero())
        # Make a streamline starting at the first unrepresented grid point
        streamlines.append(makeStreamline(F, F.x[nz[0][1]], F.y[nz[0][0]],
                                          res, spacing, maxLen, detectLoops))

    return streamlines


class VelocityField:
    def __init__(self, x, y, u, v):
        xa = np.asarray(x)
        ya = np.asarray(y)
        self.x = xa if xa.ndim == 1 else xa[0]
        self.y = ya if ya.ndim == 1 else ya[:,0]
        self.u = u
        self.v = v
        self.dx = (self.x[-1]-self.x[0])/(self.x.size-1) # assume a regular grid
        self.dy = (self.y[-1]-self.y[0])/(self.y.size-1) # assume a regular grid

        # marker for which regions have contours
        self.used = np.zeros(u.shape, dtype=bool)
        self.used[0] = True
        self.used[-1] = True
        self.used[:,0] = True
        self.used[:,-1] = True

        self.markEmpty()

    def markEmpty(self):
        for i in range(self.x.size):
            for j in range(self.y.size):
                if self.u[j,i] == 0.0 and self.v[j,i] == 0.0:
                    self.used[j,i] = True


    def interp(self, x, y, spacing):
        i = (x-self.x[0])/self.dx
        ai = i % 1

        j = (y-self.y[0])/self.dy
        aj = j % 1

        # Bilinear interpolation
        u = (self.u[j,i]*(1-ai)*(1-aj) +
             self.u[j,i+1]*ai*(1-aj) +
             self.u[j+1,i]*(1-ai)*aj +
             self.u[j+1,i+1]*ai*aj)

        v = (self.v[j,i]*(1-ai)*(1-aj) +
             self.v[j,i+1]*ai*(1-aj) +
             self.v[j+1,i]*(1-ai)*aj +
             self.v[j+1,i+1]*ai*aj)

        self.used[j:j+spacing,i:i+spacing] = True

        return u,v


def makeStreamline(field, x0, y0, res, spacing, maxLen, detectLoops=True):
    xmin, xmax, ymin, ymax = field.extents()
    d = res*np.sqrt(field.dx*field.dy)

    # forwards:
    sx = [x0]
    sy = [y0]

    x = x0
    y = y0
    i = 0
    while True:
        if x >= xmax or x <= xmin or y >= ymax or y <= ymin:
            break

        u, v = field.interp(x, y, spacing)
        theta = np.arctan2(v,u)

        x += d*np.cos(theta)
        y += d*np.sin(theta)
        sx.append(x)
        sy.append(y)

        i += 1

        # Detect closed loops and nodes
        if detectLoops and i%10 == 0:
            D = np.ndarray(len(sx)-1)
            for j in range(D.size):
                D[j] = np.hypot(x-sx[j], y-sy[j])

            if (D < 0.9*d).any():
                break

        if i > maxLen/2:
            break

    # backwards
    rx = []
    ry = []

    x = x0
    y = y0
    i = 0
    while True:
        if x >= xmax or x <= xmin or y >= ymax or y <= ymin:
            break

        u, v = field.interp(x, y, spacing)
        theta = np.arctan2(v,u)

        x -= d*np.cos(theta)
        y -= d*np.sin(theta)
        rx.append(x)
        ry.append(y)

        i += 1

        # Detect closed loops and nodes
        if detectLoops and  i % 10 == 0:
            D = np.ndarray(len(rx)-1)
            for j in range(D.size):
                D[j] = np.hypot(x-rx[j], y-ry[j])

            if (D < 0.9*d).any():
                break

        if i > maxLen/2:
            break

    rx.reverse()
    ry.reverse()

    return rx+sx, ry+sy




def drawStreamlines(streamlines, **kwargs):
    lw = kwargs.get('lw', 1)

    ax = kwargs.get('ax') or plt.axes()

    for streamline in streamlines:
        plt.plot(streamline[0], streamline[1], 'k', lw=lw)

    ax.axis('tight')

    return ax


def drawStreamlinesArrows(streamlines, **kwargs):
    mutation_scale = kwargs.get('mutation_scale', 12)
    lw = kwargs.get('lw', 1)

    ax = kwargs.get('ax') or plt.axes()

    for streamline in streamlines:
        path = mpl.path.Path(np.asarray((streamline[0], streamline[1])).T)
        patch = mpl.patches.FancyArrowPatch(path=path, arrowstyle='->', mutation_scale=mutation_scale, lw=lw)
        ax.add_patch(patch)

    ax.axis('tight')

    return ax


#def drawStreamlines(S):
#    plt.figure()
#    plt.ioff()
#    color = 'k'
#    for s in S:
#        foo = plt.plot(s[0],s[1],color)
#
#    plt.axis('tight')
#    plt.ion()
#    plt.draw()


def animateStreamlines(SS):
    plt.figure()
    color = 'k'
    for S in SS:
        plt.ioff()
        plt.clf()
        for s in S:
            foo = plt.plot(s[0],s[1],color)
        plt.axis('tight')
        plt.ion()
        plt.draw()
        raw_input('...')
